Unipolar NRZ.......

import numpy as np
import matplotlib.pyplot as plt

N = 10
# binary bit generating
n = np.random.randint(2, size=N) 
print(n);

# Signal Shaping
i=1
t = np.arange(0, N+0.01, 0.01)  # 100 Times duration set up for a single binary bit
y = np.zeros(len(t))
for j in range(len(t)):
    if t[j] <= i:  # Binary input data index Check-up Condition
        y[j] = n[i-1]  # Assign value from the mapping function
    else:
        y[j] = n[i-1]
        i += 1  # Binary input data index increment
        
# plot portion 
plt.plot(t, y, linewidth=2)

# first two of them are x-axis and last two are y-axis
plt.axis([0, N, -1.5, 1.5])  # Axis set-up
plt.grid(True)
plt.title('Unipolar NZR Signaling')
plt.show()



UNipolar RZ.......

# library 
import numpy as np
import matplotlib.pyplot as plot


N=10
# binary bit
n=np.random.randint(2,size=N);
print(n)

# signal Shaping
i=1
a=0
t=np.arange(0,N+0.01,0.01)
y=np.zeros(len(t))

for j in range(len(t)):
    if t[j]>=a and t[j]<=a+0.5:
        y[j]=n[i-1]
    elif t[j]>=a+0.5 and t[j]<=i:
        pass
    else:
        a+=1
        i+=1

plot.plot(t,y,linewidth="2")
plot.grid(True)
plot.axis([0,N,-1.5,1.5])
plot.title("Unipolar Return to Zero")
plot.show()



Polar NRZ.......

import numpy as np
import matplotlib.pyplot as plt

N=10
# bit generating
n=np.random.randint(2,size=N)
print(n)

# mapping function 
nn=np.where(n==1,1,-1)

# signal shaping
i=1
t=np.arange(0,N+0.01,0.01)
y=np.zeros(len(t))
for j in range(len(t)):
    if t[j]<=i:
        y[j]=nn[i-1]
    else:
        y[j]=nn[i-1]
        i+=1

plt.plot(t,y,linewidth="2")
plt.grid(True)
plt.axis([0,N,-1.5,1.5])
plt.title("Polar Non Return to Zero")
plt.show()


Bipolar RZ........

import numpy as np
import matplotlib.pyplot as plt

N=10
# bit generating
n=np.random.randint(2,size=N)
print(n)

# making data based on bipolar algo
nn=np.zeros(N);
flag=True
for i in range(N):
    if n[i]==1:
        if flag:
            nn[i]=1
        else:
            nn[i]=-1
        flag^=True

# signal shaping 
i=1
a=0
t=np.arange(0,N+0.01,0.01)
y=np.zeros(len(t))
for j in range(len(t)):
    if t[j]>=a and t[j]<=a+0.5:
        y[j]=nn[i-1]
    elif t[j]>=a+0.5 and t[j]<=i:
        pass
    else:
        a+=1
        i+=1

plt.plot(t,y,linewidth="2")
plt.grid(True)
plt.axis([0,N,-1.5,1.5])
plt.title("Bipolar Return to Zero")
plt.show()



Manchester........


import numpy as np
import matplotlib.pyplot as plt

N = 10  # Number of bits
n = np.random.randint(2, size=N)  # Random bit generation
print(n)

# Binary to Manchester Conversion
nnn = []
for bit in n:
    if bit == 1:
        nn = [1, -1]
    else:
        nn = [-1, 1]
    nnn.extend(nn)

# Manchester Coding Pulse Shaping
i = 0
l = 0.5
t = np.arange(0, N + 0.01, 0.01)
y = []
for j in range(len(t)):
    if t[j] <= l:  # Condition for the first half cycle
        y.append(nnn[i])  # Assign values for the first half cycle
    else:
        y.append(nnn[i])
        i += 1
        l += 0.5

plt.plot(t, y, linewidth=2)  # Linewidth 2 for clear visualization
plt.axis([0, N, -1.5, 1.5])  # Axis set-up
plt.grid(True)
plt.title("Manchester Coding")
plt.show()



ASK......

import numpy as np
import matplotlib.pyplot as plt

# Binary information at transmitter
x = np.array([1, 0, 1, 0, 1, 0, 1, 0, 1])
bp = 0.000001
print("Binary Information at transmitter:")
print(x)

# Representation of transmitting binary information as digital signal
bit = np.array([])
for n in range(len(x)):
    if x[n] == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))
# Adjust the step size of np.arange to match the length of bit
t1 = np.arange(bp / 100, 100 * len(x) * (bp / 100) + bp / 100, bp / 100)

plt.subplot(311)
plt.plot(t1, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(x), -0.5, 1.5])
plt.ylabel("Amplitude (volt)")
plt.xlabel("Time (sec)")
plt.title("Transmitting Information as Digital Signal")

# Binary ASK Modulation
A1 = 10
A2 = 5
br = 1 / bp
f = br * 10
t2 = np.arange(bp / 99, bp + bp/99, bp / 99)
ss = len(t2)
m = np.array([])
for i in range(len(x)):
    if x[i] == 1:
        y = A1 * np.cos(2 * np.pi * f * t2)
    else:
        y = A2 * np.cos(2 * np.pi * f * t2)
    m = np.concatenate((m, y))

t3 = np.arange(bp / 99, bp * len(x), bp / 99)
plt.subplot(312)
plt.plot(t3, m)
plt.grid(True)
plt.xlabel("Time (sec)")
plt.ylabel("Amplitude (volt)")
plt.title("Waveform for binary ASK Modulation Corresponding Binary Information")

# Binary ASK Demodulation
mn = np.array([])
for n in range(ss, len(m), ss):
    t = np.arange(bp / 99, bp, bp / 99)
    y = np.cos(2 * np.pi * f * t)
    mm = y * m[(n - (ss - 1)):n]
    t4 = np.arange(bp / 99, bp, bp / 99)
    z = np.trapz(mm, t4)
    zz = round((2 * z / bp))
    if zz > 7.5:
        a = 1
    else:
        a = 0
    mn = np.append(mn, a)

print("Binary Information at Receiver:")
print(mn)

# Representation of Binary Data Into Digital Signal
bit = np.array([])
for n in range(len(mn)):
    if mn[n] == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))
t4 = np.arange(bp / 100, 100 * len(mn) * (bp / 100) + bp / 100, bp / 100)

plt.subplot(313)
plt.plot(t4, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(mn), -0.5, 1.5])
plt.ylabel("Amplitude (volt)")
plt.xlabel("Time (sec)")
plt.title("Received Information as Digital Signal")

plt.tight_layout()
plt.show()



FSK.........


import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 1, 0, 1, 0, 1])
bp = 0.000001
print('Binary Information at transmitter:')
print(x)

# Representation of Transmitting binary information as digital signal
bit = np.array([])
for bit_value in x:
    if bit_value == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))

t1 = np.arange(bp / 100, 100 * len(x) * (bp / 100) + bp / 100, bp / 100)

plt.subplot(311)
plt.plot(t1, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(x), -0.5, 1.5])
plt.ylabel('Amplitude (volt)')
plt.xlabel('Time (sec)')
plt.title('Transmitting Information as Digital Signal')

# Binary FSK Modulation
A = 5
br = 1 / bp
f1 = br * 8
f2 = br * 2
t2 = np.arange(bp / 99, bp + bp / 99, bp / 99)
ss = len(t2)
m = np.array([])
for bit_value in x:
    if bit_value == 1:
        y = A * np.cos(2 * np.pi * f1 * t2)
    else:
        y = A * np.cos(2 * np.pi * f2 * t2)
    m = np.concatenate((m, y))

t3 = np.arange(bp / 99, bp * len(x) + bp / 99, bp / 99)
plt.subplot(312)
plt.plot(t3, m)
plt.grid(True)
plt.xlabel('Time (sec)')
plt.ylabel('Amplitude (volt)')
plt.title('Waveform for binary FSK Modulation Corresponding Binary Information')

# Binary FSK Demodulation
mn = np.array([])
for n in range(ss, len(m), ss):
    t = np.arange(bp / 99, bp + bp / 99, bp / 99)
    y1 = np.cos(2 * np.pi * f1 * t)
    y2 = np.cos(2 * np.pi * f2 * t)
    mm = y1 * m[(n - ss):n]
    mmm = y2 * m[(n - ss):n]
    z1 = np.trapz(mm, t)
    z2 = np.trapz(mmm, t)
    zz1 = round((2 * z1 / bp))
    zz2 = round((2 * z2 / bp))
    if zz1 > A / 2:
        a = 1
    elif zz2 > A / 2:
        a = 0
    mn = np.append(mn, a)

print('Binary Information at Receiver:')
print(mn)

# Representation of Binary Data Into Digital Signal
bit = np.array([])
for bit_value in mn:
    if bit_value == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))

t4 = np.arange(bp / 100, 100 * len(mn) * (bp / 100) , bp / 100)

plt.subplot(313)
plt.plot(t4, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(mn), -0.5, 1.5])
plt.ylabel('Amplitude (volt)')
plt.xlabel('Time (sec)')
plt.title('Received Information as Digital Signal')

plt.tight_layout()
plt.show()


PSK.......

import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 0, 1, 0, 1, 0, 1, 0, 1])
bp = 0.000001
print('Binary Information at transmitter:')
print(x)

# Representation of Transmitting binary information as digital signal
bit = np.array([])
for bit_value in x:
    if bit_value == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))

t1 = np.arange(bp / 100, 100 * len(x) * (bp / 100) + bp / 100, bp / 100)

plt.subplot(311)
plt.plot(t1, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(x), -0.5, 1.5])
plt.ylabel('Amplitude (volt)')
plt.xlabel('Time (sec)')
plt.title('Transmitting Information as Digital Signal')

# Binary PSK Modulation
A = 5
br = 1 / bp
f = br * 2
t2 = np.arange(bp / 99, bp + bp / 99, bp / 99)
m = np.array([])
for bit_value in x:
    if bit_value == 1:
        y = A * np.cos(2 * np.pi * f * t2)
    else:
        y = A * np.cos(2 * np.pi * f * t2 + np.pi)
    m = np.concatenate((m, y))

t3 = np.arange(bp / 99, bp * len(x) , bp / 99)
plt.subplot(312)
plt.plot(t3, m)
plt.grid(True)
plt.xlabel('Time (sec)')
plt.ylabel('Amplitude (volt)')
plt.title('Waveform for binary PSK Modulation Corresponding Binary Information')

# Binary PSK Demodulation
mn = np.array([])
for n in range(len(m) // len(t2)):
    t = np.arange(bp / 99, bp + bp / 99, bp / 99)
    y = np.cos(2 * np.pi * f * t)

    mm = y * m[(n * len(t2)):((n + 1) * len(t2))]

    z = np.trapz(mm, t)

    zz = round((2 * z / bp))

    if zz > 0:
        a = 1
    else:
        a = 0
    mn = np.append(mn, a)

print('Binary Information at Receiver:')
print(mn)

# Representation of Binary Data Into Digital Signal
bit = np.array([])
for bit_value in mn:
    if bit_value == 1:
        se = np.ones(100)
    else:
        se = np.zeros(100)
    bit = np.concatenate((bit, se))

t4 = np.arange(bp / 100, 100 * len(mn) * (bp / 100) + bp / 100, bp / 100)

plt.subplot(313)
plt.plot(t4, bit, linewidth=2.5)
plt.grid(True)
plt.axis([0, bp * len(mn), -0.5, 1.5])
plt.ylabel('Amplitude (volt)')
plt.xlabel('Time (sec)')
plt.title('Received Information as Digital Signal')

plt.tight_layout()
plt.show()



PAM.......


import numpy as np
import matplotlib.pyplot as plt

# Parameters
fc = 20
fm = 2
fs = 1000
t = 1
n = np.arange(0, t, 1/fs)

# Square wave generation
duty = 20
s = np.zeros(len(n))
for i in range(len(n)):
    if np.floor(2 * fc * n[i]) % 2 == 0:
        s[i] = 1

# Generating sine wave
m = np.sin(2 * np.pi * fm * n)

# PAM waveform generation
period_samp = len(n) / fc
ind = np.arange(0, len(n), int(period_samp))
on_samp = int(np.ceil(period_samp * duty / 100))
pam = np.zeros(len(n))
for i in ind:
    pam[i:i+on_samp] = m[i]

# Plotting
plt.figure(figsize=(8, 6))
plt.subplot(3, 1, 1)
plt.plot(n, s)
plt.title('Square Wave')
plt.ylim(-0.2, 1.2)

plt.subplot(3, 1, 2)
plt.plot(n, m)
plt.title('Sine Wave')
plt.ylim(-1.2, 1.2)

plt.subplot(3, 1, 3)
plt.plot(n, pam)
plt.title('PAM Waveform')
plt.ylim(-1.2, 1.2)

plt.tight_layout()
plt.show()


QPSK......


import numpy as np
import matplotlib.pyplot as plt

# Input bits
x = np.array([1, 0, 1, 1, 0, 1, 1, 1, 1, 1])

# Bits to polar
p = np.where(x == 0, -1, 1)
print(p)
# Separation of even and odd sequences
even_seq = []
odd_seq = []

for i in range(len(p)):
    if i % 2 == 0:
        even_seq.append(p[i])
    else:
        odd_seq.append(p[i])

# NRZ polar line coder signal generation
t = np.arange(0, len(x), 0.01)
even_ps = np.zeros(len(t))
odd_ps = np.zeros(len(t))

i = 0
m = np.arange(2, len(x) + 1, 2)
print(m)
for j in range(len(t)):
    if t[j] <= m[i]:
        even_ps[j] = even_seq[i]
        odd_ps[j] = odd_seq[i]
    else:
        even_ps[j] = even_seq[i]
        odd_ps[j] = odd_seq[i]
        i += 1

plt.subplot(421)
plt.plot(t, even_ps, 'r')
plt.title('NRZ Polar Line Coded Signal')
plt.subplot(422)
plt.plot(t, odd_ps, 'r')
plt.title('NRZ Polar Line Coded Signal')

# Carrier signals generation
c1 = np.cos(2 * np.pi * 1 * t)
c2 = np.sin(2 * np.pi * 1 * t)

plt.subplot(423)
plt.plot(t, c1, 'r')
plt.title('Carrier Signal (Cosine)')
plt.subplot(424)
plt.plot(t, c2, 'b')
plt.title('Carrier Signal (Sine)')

# QPSK Waveform generation
r1 = even_ps * c1
r2 = odd_ps * c2
qpsk_sig = r1 - r2

plt.subplot(425)
plt.plot(t, r1, 'r')
plt.title('QPSK Modulated Signal (Even)')
plt.subplot(426)
plt.plot(t, r2, 'b')
plt.title('QPSK Modulated Signal (Odd)')
plt.subplot(427)
plt.plot(t, qpsk_sig, 'b')
plt.title('QPSK Signal')

plt.tight_layout()
plt.show()







